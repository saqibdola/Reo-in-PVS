
%% PVS Version 6.0 - International Allegro CL Enterprise Edition 9.0 [Linux (x86)] (Jan 14, 2013 3:16)
%% 9.0 [Linux (x86)] (Jan 14, 2013 3:16)
$$$ttreo.pvs
treo: THEORY 
BEGIN 

Importing reo

Input, T1, T2, TD1, Output: VAR TD;

seq: var sequence[Data];
i, n: var nat;

str_nth1(n,TD1): RECURSIVE TD = 
	        	IF n=0 THEN TD1 
	        	ELSE str_nth1(n-1, next(TD1))
	        	ENDIF 
		MEASURE n

str_nth(n, TD1): TD= nth(str_nth1(n,TD1), n)
Inc_T: AXIOM FORALL (T1, n): a?(str_nth(n,T1)) < a?(str_nth(n, next(T1)))

Teq(T1,T2): bool = FORALL (n:nat): a?(str_nth(n,T1)) = a?(str_nth(n,T2))
Tle(T1,T2): bool = FORALL (n:nat): a?(str_nth(n,T1)) < a?(str_nth(n,T2))
Tgt(T1,T2): bool = FORALL (n:nat): a?(str_nth(n,T1)) > a?(str_nth(n,T2))
Tneq(T1,T2): bool = FORALL (n:nat): a?(str_nth(n,T1)) /= a?(str_nth(n,T2))
Teqt(T1,T2)(t:Time): bool = FORALL (n:nat): a?(str_nth(n,T1)) + t = a?(str_nth(n,T2))
Tltt(T1,T2)(t:Time): bool = FORALL (n:nat): a?(str_nth(n,T1)) + t < a?(str_nth(n,T2))
Tgtt(T1,T2)(t:Time): bool = FORALL (n:nat): a?(str_nth(n,T1)) + t > a?(str_nth(n,T2))
Deq(T1, T2): bool= D(T1)= D(T2)

Teqtn(T1, T2)(t:Time)(n:posnat): Recursive bool= if n=1 THEN Teqt(T1,T2)(t) ELSE EXISTS(T3:TD): Teqtn(T1,T3)(t)(n-1) & Teqt(T3,T2)(t)
ENDif Measure n

Sync(Input, Output): bool = Teq(Input, Output) & Deq(Input, Output)

SyncD(Input, Output): bool = Teq(Input, Output)

Fifo1(Input, Output): bool = Tle(Input, Output) & 
	     	      	     Tle(Output, next(Input)) &
			     Deq(Input, Output)

Fifo1e(Input, Output)(e:Data)(n:nat): bool = Tgt(Input, Output) &  
Tle(Input,next(Output))   & e?(nth(Output,n))(e)
			     & Deq(Input, (next(Output)))

Fifon(s1, s2: TD)(n:posnat): Recursive bool = if n=1 Then Fifo1(s1, s2) ELSE
EXISTS(s3:TD): Fifon(s1,s3)(n-1) AND Fifo1(s3, s2) ENDIF MEasure n

ASD(Input, Output)(n:nat): INDUCTIVE bool=
	   	    	      (NOT a?(nth(Input,n))) =  a?(nth(Output, n))
			      & a?(nth(Input,n)) < a?(nth(Output, n))
			      & ASD((next(Input), Output))(n)
			      & a?(nth(Input,n))> a?(nth(Output, n))
			      & ASD(Input, next(Output))(n)

Lossysync(Input, Output)(n:nat): INDUCTIVE bool = 
		 		 Lossysync(next(Input), next(Output))(n) 
				& nth(Output,n)= nth(Input,n) 
				 OR Lossysync(next(Input), Output)(n)

s1,s2,s3: VAr TD

timeout, reset, expire, off:[Data->bool]

timert(Input, Output)(t:Time)(d:Data): bool = 
      (FORALL (n:nat): a?(str_nth(n,Input)) + t < a?(str_nth(n,(next(Input)))) 
      & Teqt(Input, Output)(t) & t?(str_nth(n, Output)) = timeout(d))

Ttimern(T1, T2)(t:Time)(d:Data)(n:posnat): Recursive bool= if n=1 then 
timert(T1,T2)(t)(d) ELSE Exists(T3:TD): Ttimern(T1,T3)(t)(d)(n-1) and timert(T2,T3)(t)(d)
ENDif measure n

offtimert(Input, Output)(t:Time)(d:Data): INDUCTIVE bool = 
      (FORALL (n:nat): t?(str_nth(n,Input)) = off(d) OR 
               a?(str_nth(n,Input))+t < a?(str_nth(n,next(Input)))
       & t?(nth(next(Input),n))= off(d) 
         IMPLIES (offtimert(next(next(Input)), Output)(t)(d))
       & (NOT t?(nth(next(Input),n)) = off(d) 
         IMPLIES  a?(nth(Input,n))= a?(nth(Input,n))+t
       &  t?(nth(Output, n)) =  off(d) 
       &  offtimert(next(Input), next(Output))(t)(d)))

rsttimert(Input, Output)(t:Time)(d:Data): Inductive bool =
      (FORALL (n:nat): t?(str_nth(n,Input)) = reset(d)  
       OR a?(str_nth(n,Input))+t < a?(str_nth(n,next(Input)))
       & t?(nth(next(Input),n))= reset(d) 
        IMPLIES (rsttimert(next(Input), Output)(t)(d))
       & (NOT t?(nth(next(Input),n)) = reset(d) 
        IMPLIES  a?(nth(Input,n))= a?(nth(Input,n))+t
       &  t?(nth(Output, n)) =  reset(d) 
       &  rsttimert(next(Input), next(Output))(t)(d)))

exptimert(Input, Output)(t:Time)(d:Data): Inductive bool =
      (FORALL (n:nat): t?(str_nth(n,Input)) = expire(d)  
       OR a?(str_nth(n,Input))+t < a?(str_nth(n,next(Input)))
       & t?(nth(next(Input),n))= expire(d) 
        IMPLIES a?(nth(Output,n)) = a?(nth(next(Input),n)) 
       & t?(nth(Output,n))= expire(d) 
       & (exptimert(next(Input), next(Output))(t)(d))
       & (NOT t?(nth(next(Input),n)) = expire(d) 
        IMPLIES  a?(nth(Input,n))= a?(nth(Input,n))+t
       & t?(nth(Output, n)) =  expire(d) 
       & exptimert(next(Input), next(Output))(t)(d)))

Merge(s1, s2,s3)(n:nat): INDUCTIVE  bool =
  (NOT (a?(nth(s1,n)))= (a?(nth(s2,n))))
  AND (
        ((a?(nth(s1,n)) < (a?(nth(s2,n)))) IMPLIES 
         nth(s3,n)= nth(s1,n))
  AND Merge(next(s1), s2, next(s3))(n))
  AND (
       ((a?(nth(s1,n)) > (a?(nth(s2,n)))) IMPLIES 
           nth(s3,n)= nth(s2,n))
  AND Merge(s1, next(s2), next(s3))(n))

eqtltt: LEMMA (FORALL (A,B:TD, t:Time,n:nat): Tltt(A,B)(t) 
               Implies a?(str_nth(n,A))+t < a?(str_nth(n,B)))

eqteqt: LEMMA (FORALL (A,B:TD, t:Time,n:nat): Teqt(A,B)(t) 
               Implies a?(str_nth(n,A))+t = a?(str_nth(n,B)))

teqttltt: LEMMA (FORALL (A,B,C:TD, t:Time): Teqt(A,B)(t) AND Tle(A, B) 
               Implies Tltt(A, C)(t))

tgt: LEmma (Forall (A,B: TD): Tgt(A, B) IMPLIES Tgt(next(s1), next(s2)))

tgttransfer: LEMMA (FORALL(A,B,C: TD): Tgt(next(B), A) AND Tgt(next(C), B)
              IMPLIES Tgt(next(next(s3)), A))

lt_transfer: LEMMA (FORALL(A,B,C:TD): Tle(A,B) and Tle(A,C) IMPLIES Tle(A,C))

eq_transfer: LEMMA (FORALL(A,B,C:TD, t:Time): Teq(A,B) and Teqt(B,C)(t) 
	     IMPLIES Teqt(A,C)(t))

merge_transfer: LEMMA (FORALL(A,B,C,D,E,F:TD, t:Time,n:nat): Merge(A,B,C)(n) and 
   Teqt(A, D)(t) and Teqt(B, E)(t) and Merge(D, E, F)(n) IMPLIES Teqt(C, F)(t))

t11: lemma FORALL (s1,s2:TD, t:Time,n:posnat): Fifon(s1,s2)(n) 
                   IMPLIES Tltt(s1,s2)(t) and Deq(s1,s2)

LB_fifo1: THEOREM (FORALL (A,B,C,D,E:TD, t:Time,d:Data):
timert(A,C)(t)(d) AND Fifo1(A,D) AND SyncD(D,E) AND Fifo1(C,E) AND Sync(D,B)
IMPLIES Deq(A,B) and Tltt(A,B)(t))

nt_connector: THEOREM (FORALL (A,B,C,D,E,F,G,I,C1,D1:TD, t:Time,d:Data,n:nat): 
   Sync(A,G) AND Lossysync(G,E)(n) AND Lossysync(G,F)(n) AND Sync(E,I) AND
   Sync(F,I) AND SyncD(G,I) AND Merge(E,F,I)(n) AND Sync(E,C) AND Sync(F,D) AND
   timert(C,C1)(t)(d) AND timert(D,D1)(t)(d) AND Merge(C1,D1,B)(n) IMPLIES Teqt(A,B)(t))

timed_fifo: THEOREM (FORALL (A,B,C,D,E:TD, t:Time,d:Data):
Fifo1(A,D) AND Fifo1(D,E) AND Sync(E,B) AND SyncD(C,E) AND 
Teqt(A,C)(t) IMPLIES Teqt(A,B)(t) and Tle(B,next(next(A))))

timed_fifon: THEOREM (FORALL (A,B,C,D,E:TD, t:Time,d:Data, n:nat):
Fifon(A,E)(n+1) AND Sync(E,B) AND SyncD(C,E) AND 
Ttimern(A,C)(t)(d)(n+1) IMPLIES Teqtn(A,B)(t)(n+1) AND Deq(A,B))%Tle(B, next(next(A))))

expire_fifo: THEOREM (FORALL (A,B,C,D,E,F,G,H:TD, t:Time,d:Data, n:nat):
Sync(A,C) AND Sync(C,F) AND Fifon(C,D)(n+1) AND timert(F,G)(t)(d) AND
Lossysync(G,H)(n) AND SyncD(D,H) AND Lossysync(D,E)(n) AND Sync(E,H) AND Sync(E,B)
IMPLIES (Tltt(A,B)(t) OR Teqt(A,B)(t)) & Deq(A,B))

End treo


$$$ttreo.prf
(treo
 (lessp_TCC1 0
  (lessp_TCC1-1 nil 3712123863
   ("" (inst 1 "lambda (x, y: sequence[Time]): false")
    (("" (grind) nil nil)) nil)
   ((irreflexive? const-decl "bool" relations nil)
    (transitive? const-decl "bool" relations nil)
    (FALSE const-decl "bool" booleans nil)
    (strict_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (sequence type-eq-decl nil sequences nil)
    (Time type-eq-decl nil treo nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   nil))
 (greaterp_TCC1 0
  (greaterp_TCC1-1 nil 3712123863
   ("" (expand "strict_order?")
    (("" (typepred "<")
      (("" (expand "strict_order?")
        (("" (flatten)
          (("" (split)
            (("1" (expand "irreflexive?") (("1" (propax) nil nil)) nil)
             ("2" (expand "transitive?")
              (("2" (skeep)
                (("2" (inst - "z" "y" "x") (("2" (assert) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((< const-decl "(strict_order?[sequence[Time]])" treo nil)
    (pred type-eq-decl nil defined_types nil)
    (sequence type-eq-decl nil sequences nil)
    (Time type-eq-decl nil treo nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (transitive? const-decl "bool" relations nil)
    (irreflexive? const-decl "bool" relations nil)
    (strict_order? const-decl "bool" orders nil))
   nil))
 (str_nth1_TCC1 0
  (str_nth1_TCC1-1 nil 3712123863 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil))
 (str_nth1_TCC2 0
  (str_nth1_TCC2-1 nil 3712123863 ("" (termination-tcc) nil nil) nil
   nil))
 (Teqtn_TCC1 0
  (Teqtn_TCC1-1 nil 3718532493 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (Teqtn_TCC2 0
  (Teqtn_TCC2-1 nil 3718532493 ("" (termination-tcc) nil nil) nil nil))
 (eqtltt 0
  (eqtltt-1 nil 3712123869
   ("" (skosimp)
    (("" (expand "Tltt")
      (("" (expand "b2n") (("" (inst?) nil nil)) nil)) nil))
    nil)
   ((Tltt const-decl "bool" treo nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (b2n const-decl "nbit" bit nil))
   shostak))
 (eqteqt 0
  (eqteqt-1 nil 3712124119
   ("" (skosimp)
    (("" (expand "Teqt")
      (("" (expand "b2n") (("" (inst?) nil nil)) nil)) nil))
    nil)
   ((Teqt const-decl "bool" treo nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (b2n const-decl "nbit" bit nil))
   shostak))
 (teqttltt 0
  (teqttltt-1 nil 3712124314
   ("" (skosimp)
    (("" (expand "Teqt")
      (("" (expand "Tle")
        (("" (expand "Tltt")
          (("" (skosimp)
            (("" (expand "b2n")
              (("" (inst?)
                (("" (assert)
                  (("" (inst?)
                    (("" (typepred "<")
                      (("" (expand "strict_order?")
                        (("" (flatten)
                          (("" (expand "transitive?")
                            (("" (assert) (("" (grind) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((Teqt const-decl "bool" treo nil) (Tltt const-decl "bool" treo nil)
    (b2n const-decl "nbit" bit nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal"
     real_types nil)
    (< const-decl "(strict_order?[sequence[Time]])" treo nil)
    (strict_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (sequence type-eq-decl nil sequences nil)
    (Time type-eq-decl nil treo nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (a? const-decl "bool" treo nil) (str_nth const-decl "TD" treo nil)
    (nth const-decl "TD" treo nil)
    (irreflexive? const-decl "bool" relations nil)
    (transitive? const-decl "bool" relations nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (Tle const-decl "bool" treo nil))
   shostak))
 (tgt 0
  (tgt-1 nil 3712124426 ("" (skosimp) (("" (grind) nil nil)) nil)
   ((Tgt const-decl "bool" treo nil) (b2n const-decl "nbit" bit nil)
    (a? const-decl "bool" treo nil) (str_nth const-decl "TD" treo nil)
    (nth const-decl "TD" treo nil))
   shostak))
 (tgttransfer 0
  (tgttransfer-1 nil 3712124607
   ("" (skosimp) (("" (grind) nil nil)) nil)
   ((Tgt const-decl "bool" treo nil) (b2n const-decl "nbit" bit nil)
    (a? const-decl "bool" treo nil) (str_nth const-decl "TD" treo nil)
    (nth const-decl "TD" treo nil))
   shostak))
 (lt_transfer 0
  (lt_transfer-1 nil 3712124714 ("" (skosimp) nil nil) nil shostak))
 (eq_transfer 0
  (eq_transfer-1 nil 3712124875
   ("" (skosimp) (("" (grind) nil nil)) nil)
   ((Teqt const-decl "bool" treo nil) (b2n const-decl "nbit" bit nil)
    (Teq const-decl "bool" treo nil) (a? const-decl "bool" treo nil)
    (str_nth const-decl "TD" treo nil) (nth const-decl "TD" treo nil))
   shostak))
 (merge_transfer 0
  (merge_transfer-1 nil 3712125074
   ("" (skosimp) (("" (grind) nil nil)) nil)
   ((nth const-decl "TD" treo nil) (str_nth const-decl "TD" treo nil)
    (a? const-decl "bool" treo nil) (b2n const-decl "nbit" bit nil)
    (Teqt const-decl "bool" treo nil))
   shostak))
 (t11 0
  (t11-1 nil 3717134453
   ("" (skolem!)
    (("" (expand "Fifon")
      (("" (lift-if)
        (("" (split)
          (("1" (flatten) (("1" (grind) nil nil)) nil)
           ("2" (flatten) (("2" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((Tltt const-decl "bool" treo nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Fifo1 const-decl "bool" treo nil) (Deq const-decl "bool" treo nil)
    (Tle const-decl "bool" treo nil) (b2n const-decl "nbit" bit nil)
    (a? const-decl "bool" treo nil) (str_nth const-decl "TD" treo nil)
    (nth const-decl "TD" treo nil) (Fifon def-decl "bool" treo nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   shostak))
 (LB_fifo1 0
  (LB_fifo1-1 nil 3712371939
   ("" (skolem!)
    (("" (flatten)
      (("" (expand "timert")
        (("" (expand "Fifo1")
          (("" (expand "SyncD")
            (("" (expand "Sync")
              (("" (expand "next")
                (("" (expand "suffix")
                  (("" (expand "str_nth")
                    (("" (expand "Deq")
                      (("" (expand "Teq")
                        (("" (expand "Tle")
                          (("" (expand "Tltt")
                            (("" (typepred "<")
                              ((""
                                (flatten)
                                ((""
                                  (assert)
                                  ((""
                                    (inst?)
                                    ((""
                                      (skosimp)
                                      ((""
                                        (inst?)
                                        ((""
                                          (typepred "n!1")
                                          ((""
                                            (inst?)
                                            ((""
                                              (inst?)
                                              ((""
                                                (inst?)
                                                ((""
                                                  (inst?)
                                                  ((""
                                                    (expand
                                                     "strict_order?")
                                                    ((""
                                                      (expand
                                                       "irreflexive?")
                                                      ((""
                                                        (expand
                                                         "transitive?")
                                                        ((""
                                                          (flatten)
                                                          ((""
                                                            (assert)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((Fifo1 const-decl "bool" treo nil)
    (Sync const-decl "bool" treo nil)
    (suffix const-decl "sequence[Data]" treo nil)
    (Deq const-decl "bool" treo nil) (Tle const-decl "bool" treo nil)
    (< const-decl "(strict_order?[sequence[Time]])" treo nil)
    (strict_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (sequence type-eq-decl nil sequences nil)
    (Time type-eq-decl nil treo nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (irreflexive? const-decl "bool" relations nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal"
     real_types nil)
    (transitive? const-decl "bool" relations nil)
    (Tltt const-decl "bool" treo nil) (Teq const-decl "bool" treo nil)
    (str_nth const-decl "TD" treo nil) (next const-decl "TD" treo nil)
    (SyncD const-decl "bool" treo nil)
    (timert const-decl "bool" treo nil))
   shostak))
 (nt_connector 0
  (nt_connector-1 nil 3712372486
   ("" (induct "n")
    (("1" (skosimp)
      (("1" (expand "Lossysync")
        (("1" (expand "Merge")
          (("1" (expand "Sync")
            (("1" (expand "timert")
              (("1" (expand "SyncD")
                (("1" (flatten)
                  (("1" (assert)
                    (("1" (split)
                      (("1" (expand "next")
                        (("1" (expand "suffix")
                          (("1" (expand "nth")
                            (("1" (expand "Teqt")
                              (("1"
                                (assert)
                                (("1"
                                  (skosimp)
                                  (("1"
                                    (inst?)
                                    (("1"
                                      (assert)
                                      (("1"
                                        (expand "str_nth")
                                        (("1" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (expand "Teqt")
                        (("2" (skosimp)
                          (("2" (assert) (("2" (grind) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (skosimp*)
      (("2" (expand "Teqt")
        (("2" (inst?)
          (("2" (inst?)
            (("2" (inst?)
              (("2" (inst?)
                (("2" (inst?)
                  (("2" (skosimp)
                    (("2" (assert)
                      (("2" (split)
                        (("1" (inst?) nil nil)
                         ("2" (typepred "j!1")
                          (("2" (assert) (("2" (grind) nil nil)) nil))
                          nil)
                         ("3" (assert) (("3" (grind) nil nil)) nil)
                         ("4" (assert) (("4" (grind) nil nil)) nil)
                         ("5" (assert) (("5" (grind) nil nil)) nil)
                         ("6" (grind) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (Data nonempty-type-decl nil treo nil)
    (sequence type-eq-decl nil sequences nil)
    (Time type-eq-decl nil treo nil) (TD type-eq-decl nil treo nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (Sync const-decl "bool" treo nil)
    (Lossysync inductive-decl "bool" treo nil)
    (SyncD const-decl "bool" treo nil)
    (Merge inductive-decl "bool" treo nil)
    (timert const-decl "bool" treo nil)
    (Teqt const-decl "bool" treo nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (next const-decl "TD" treo nil) (nth const-decl "TD" treo nil)
    (str_nth const-decl "TD" treo nil) (a? const-decl "bool" treo nil)
    (Teq const-decl "bool" treo nil) (Deq const-decl "bool" treo nil)
    (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal"
     real_types nil)
    (suffix const-decl "sequence[Data]" treo nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (t? const-decl "bool" treo nil) (b2n const-decl "nbit" bit nil)
    (NOT const-decl "[bool -> bool]" booleans nil))
   shostak))
 (timed_fifo 0
  (timed_fifo-1 nil 3712372712
   ("" (skosimp) (("" (grind) nil nil)) nil)
   ((Teqt const-decl "bool" treo nil)
    (SyncD const-decl "bool" treo nil)
    (Sync const-decl "bool" treo nil) (Teq const-decl "bool" treo nil)
    (Fifo1 const-decl "bool" treo nil) (Deq const-decl "bool" treo nil)
    (Tle const-decl "bool" treo nil) (b2n const-decl "nbit" bit nil)
    (a? const-decl "bool" treo nil) (str_nth const-decl "TD" treo nil)
    (nth const-decl "TD" treo nil))
   shostak))
 (timed_fifon 0
  (timed_fifon-1 nil 3717390941
   ("" (induct "n")
    (("1" (skosimp)
      (("1" (assert)
        (("1" (expand "Fifon")
          (("1" (expand "Ttimern")
            (("1" (expand "Sync")
              (("1" (expand "Teq")
                (("1" (expand "SyncD")
                  (("1" (expand "Fifo1")
                    (("1" (flatten)
                      (("1" (assert) (("1" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (assert)
      (("2" (skosimp*)
        (("2" (expand Fifon -2)
          (("2" (expand Ttimern -5)
            (("2" (skosimp)
              (("2" (inst?)
                (("2" (assert)
                  (("2" (hide -1)
                    (("2" (skosimp*)
                      (("2" (assert) (("2" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (Data nonempty-type-decl nil treo nil)
    (sequence type-eq-decl nil sequences nil)
    (Time type-eq-decl nil treo nil) (TD type-eq-decl nil treo nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (Fifon def-decl "bool" treo nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Sync const-decl "bool" treo nil)
    (SyncD const-decl "bool" treo nil)
    (Ttimern def-decl "bool" treo nil) (Teqtn def-decl "bool" treo nil)
    (Deq const-decl "bool" treo nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (even_plus_odd_is_odd application-judgement "odd_int" integers nil)
    (Teq const-decl "bool" treo nil) (Fifo1 const-decl "bool" treo nil)
    (nth const-decl "TD" treo nil) (str_nth const-decl "TD" treo nil)
    (a? const-decl "bool" treo nil) (b2n const-decl "nbit" bit nil)
    (Tle const-decl "bool" treo nil) (next const-decl "TD" treo nil)
    (Teqt const-decl "bool" treo nil) (t? const-decl "bool" treo nil)
    (timert const-decl "bool" treo nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   shostak))
 (expire_fifo 0
  (expire_fifo-1 nil 3712373381
   ("" (induct "n")
    (("1" (assert)
      (("1" (skosimp)
        (("1" (expand "Fifon")
          (("1" (expand "Fifo1")
            (("1" (expand "Lossysync")
              (("1" (expand "Lossysync")
                (("1" (expand "Sync")
                  (("1" (expand "SyncD")
                    (("1" (expand "timert")
                      (("1" (expand "Teq")
                        (("1" (expand "Deq")
                          (("1" (expand "Tltt")
                            (("1" (flatten)
                              (("1"
                                (assert)
                                (("1"
                                  (hide -3 -9 -10 -11 -14)
                                  (("1"
                                    (prop)
                                    (("1"
                                      (skosimp)
                                      (("1"
                                        (inst?)
                                        (("1"
                                          (hide -7)
                                          (("1"
                                            (assert)
                                            (("1"
                                              (inst?)
                                              (("1"
                                                (typepred "n!1" "<")
                                                (("1"
                                                  (assert)
                                                  (("1"
                                                    (grind)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (inst?)
                                      (("1"
                                        (hide -7 -8)
                                        (("1"
                                          (assert)
                                          (("1" (grind) nil nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (assert)
                                        (("2" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (assert)
      (("2" (skosimp*)
        (("2" (expand Fifon -4)
          (("2" (inst?)
            (("2" (assert)
              (("2" (hide -1)
                (("2" (expand "Tltt")
                  (("2" (skosimp*)
                    (("2" (split)
                      (("1" (skosimp)
                        (("1" (typepred "<")
                          (("1" (expand "strict_order?")
                            (("1" (expand "irreflexive?")
                              (("1"
                                (expand "transitive?")
                                (("1"
                                  (assert)
                                  (("1" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (expand "Deq")
                        (("2" (assert) (("2" (grind) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((Teqt const-decl "bool" treo nil) (t? const-decl "bool" treo nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (irreflexive? const-decl "bool" relations nil)
    (transitive? const-decl "bool" relations nil)
    (nth const-decl "TD" treo nil) (str_nth const-decl "TD" treo nil)
    (a? const-decl "bool" treo nil) (b2n const-decl "nbit" bit nil)
    (Tle const-decl "bool" treo nil) (next const-decl "TD" treo nil)
    (posreal_plus_nnreal_is_posreal application-judgement "posreal"
     real_types nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (strict_order? const-decl "bool" orders nil)
    (< const-decl "(strict_order?[sequence[Time]])" treo nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal"
     real_types nil)
    (Teq const-decl "bool" treo nil) (Fifo1 const-decl "bool" treo nil)
    (even_plus_odd_is_odd application-judgement "odd_int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (Deq const-decl "bool" treo nil) (Tltt const-decl "bool" treo nil)
    (SyncD const-decl "bool" treo nil)
    (Lossysync inductive-decl "bool" treo nil)
    (timert const-decl "bool" treo nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (Fifon def-decl "bool" treo nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (Sync const-decl "bool" treo nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (TD type-eq-decl nil treo nil) (Time type-eq-decl nil treo nil)
    (sequence type-eq-decl nil sequences nil)
    (Data nonempty-type-decl nil treo nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil))
   shostak)))

