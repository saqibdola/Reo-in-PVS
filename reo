
%% PVS Version 6.0 - International Allegro CL Enterprise Edition 9.0 [Linux (x86)] (Jan 14, 2013 3:16)
%% 9.0 [Linux (x86)] (Jan 14, 2013 3:16)
$$$reo1.pvs
reo: THEORY 
BEGIN 

Time: Type =posreal;
Data: TYPE+
A,B: TYPE= Data
T: TYPE =Time

TD: TYPE = [# T: sequence[Time], 
              D: sequence[Data] #]

Input, T1, T2, TD, Output: VAR TD;

pair: TYPE = [A,T]

<: (strict_order?[sequence[Time]])
>: (strict_order?[sequence[Time]]) = 
     LAMBDA (s1, s2: sequence[Time]): s2 < s1

DrT:[pair -> A]; 
TrD:[pair -> T]; 

e?(T1)(e:Data): bool = FORALL (a: Data,t:Time): DrT(a,t)=e;
a?(T1):bool =  FORALL (a: Data,t:Time): DrT(a,t)=a;
t?(T1):bool =  FORALL (a: Data,t:Time): TrD(a,t)=t;

Teq(Input,Output): bool = T(Input) = T(Output)
Tle(Input,Output): bool = T(Input) < T(Output)
Tgt(Input, Output): bool = T(Input) > T(Output)
Tneq(Input,Output): bool = T(Input) /= T(Output)  
Deq(Input, Output): bool= D(Input) = D(Output);

seq: var sequence[Data];
i, n: var nat;

suffix(seq, n): sequence[Data]  = (LAMBDA i:seq(i+n))
next(T1): TD = T1 WITH [D:=(suffix(T1`D, 1))]
nth(T1,n): TD=  T1 WITH [D:= (suffix(T1`D, n))];

pat: VAR setof[Data];
DI: VAR Data
member(pat): bool = EXISTS (DI: Data): pat(DI) 

Sync(Input, Output): bool = Teq(Input, Output) & 
	     	            Deq(Input, Output)

SyncD(Input, Output): bool = Teq(Input, Output)

Filter(Input, Output)(pat): INDUCTIVE bool= 
	         a?(Input) = member(pat) IMPLIES 
                  Teq(Input, Output) & Deq(Input, Output)
                   & (Filter(next(Input), next(Output))(pat))
                  and  (a?(Input) /= member(pat) IMPLIES 
                             Filter(next(Input), Output)(pat))

Producer(Input, Output)(pat): bool = member(pat) & 
			      	   Teq(Input, Output)

Fifo1(Input, Output): bool = Tle(Input, Output) & 
	     	      	     Tle(Output, next(Input)) &
			     Deq(Input, Output)

Fifo1e(Input, Output)(e:Data)(n:nat): bool = Tgt(Input, Output) & 
                   Tle(Input,next(Output))  & e?(nth(Output,n))(e)
			     & Deq(Input, (next(Output)))

Fifon(Input, Output: TD)(n:posnat): Recursive bool = IF n=1 Then 
                    Fifo1(Input, Output) ELSE 
                 EXISTS(s3:TD): Fifon(Input, s3)(n-1) 
               AND Fifo1(s3, Output) ENDIF MEasure n

Lossysync(Input, Output)(n:nat): INDUCTIVE bool = 
		 Lossysync(next(Input), next(Output))(n) 
	         & nth(Output,n)= nth(Input,n) 
		 OR Lossysync(next(Input), Output)(n)

ASD(Input, Output)(n:nat): INDUCTIVE bool=
	   	 (NOT a?(nth(Input,n))) =  a?(nth(Output, n))
	     & a?(nth(Input,n)) < a?(nth(Output, n))
	     & ASD((next(Input), Output))(n)
	     & a?(nth(Input,n)) > a?(nth(Output, n))
	     & ASD(Input, next(Output))(n)

Join(Input,Output): bool = Input=Output

s1, s2, s3, A, B, C, C1, C2, D, E, F, G,H,I,J, TD1,TD2: VAR TD;

FT(A, B, C): bool= Sync(A,B) and Fifo1(B,C)

Merge(s1, s2,s3)(n:nat): INDUCTIVE bool =
  NOT (a?(nth(s1,n)))= (a?(nth(s2,n)))
  AND (
        ((a?(nth(s1,n)) < (a?(nth(s2,n)))) IMPLIES
    nth(s3,n)= nth(s1,n))
    & Merge(next(s1), s2, next(s3))(n))
  AND (
        ((a?(nth(s1,n)) > (a?(nth(s2,n)))) IMPLIES
        nth(s3,n)= nth(s2,n))
        & Merge(s1, next(s2), next(s3))(n))

trans_equal: LEMMA Teq(s1,s2) AND Teq(s2,s3) IMPLIES Teq(s1,s3)

trans_equal2: LEMMA Teq(s1,s2) IMPLIES (Teq(next(s1), next(s2)))

trans_equal3: LEMMA Tle(s1,s2) AND Tle(s2,s3) IMPLIES Tle(s1,s3)

trans_equal5: LEMMA Tgt(s1,s2) AND Tgt(s2,s3) IMPLIES Tgt(s1,s3)

trans_equal6: LEMMA Deq(s1,s2) AND Deq(s2,s3) IMPLIES Deq(s1,s3)

T1: THEOREM Sync(A,B) & Fifo1(B,C) IMPLIES Tle(A,C) & Teq(A,B) &  Deq(A,C)

fto: THEOREM Sync(A,B) & Join(B,C) and Sync(C,D) IMPLIES Teq(A,D) and Deq(A,D)

tcr: THEOREM Sync(A,B) and Join(B,C) & Join(B,E) AND Sync(E,F) AND Sync(C,D) 
IMPLIES Teq(A,F) and Teq(A,D) and Deq(A,F) and Deq(A,D) and Deq(A,F)

wcr: THEOREM Sync(A,B) AND Join(B, C) and Join(B, E) AND SyncD(E,F) AND 
  Sync(C,D) IMPLIES Teq(A,D) and Deq(A,D)

ex52: THEOREM  Sync(A,G) & Lossysync(G,D)(n) & Lossysync(G,E)(n) & 
SyncD(G,F) & Sync(D,F) and Sync(E,F) & Sync(D,B) & Sync(E,C) IMPLIES
Teq(A,C) OR Teq(A,D) 

ex52new: THEOREM  Sync(A,G) & Lossysync(G,D)(n) & 
Lossysync(G,E)(n) & SyncD(G,F) & Sync(D,F) & Sync(E,F) & 
Sync(D,B) & Sync(E,C) IMPLIES
Teq(A,C) OR Teq(A,D) 

sequencer(A, G):bool= FORALL(B,C,D,E,F:TD, e:Data, n:nat): 
Fifo1e(A,B)(e)(n) & Sync(B,E) & Fifo1(B,C) &
Sync(C,F) & Fifo1(C,D) & Sync(D, G) & Sync(D,A)

seq: THEoREM sequencer(A,G) IMPLIES Tle(G, next(E)) and Tle(E,F) & Tle(F,G) & Deq(E,F) and Deq(F,G)

lemma7: LEMMA A=B IMPLIES Sync(A,B)

T2LI: Theorem SyncD(A, B) AND Fifo1(A, C1) AND Sync(B, C2) IMPLIES Tle(C2, C1) and Tle(C1, next(C2))

R3LI: Theorem FORALL (A,C,D:TD): 
(EXISTS B: Fifo1(A,B) & Sync(B, C) & Sync(B, D)) IMPLIES 
 (EXISTS E: Sync(A, E) & Fifo1(E,C) & Fifo1(E,D))

E4LI: Theorem FORALL (A, B, C: TD): 
(exists E,F,G: Sync(A, E) & Fifo1(E, F) & Sync(F,B) & Fifo1(E,G) & Sync(G, C) & 
SyncD(F,G)) IMPLIES 
(exists D: Fifo1(A,D) & Sync(D, B) & Sync(D,C))

ordering: THEOREM Sync(A,C) & SyncD(A,B) & Fifo1(B,C) IMPLIES Teq(A,C) & Tle(B,C)

gn: THEOREM FORALL (n:nat): Fifon(s1, s2)(n+1) IMPLIES Tle(s1, s2) and Deq(s1,s2)

g1: THEOREM Fifon(s1,s2)(1) = Fifo1(s1,s2)




End reo

$$$reo1.prf
(reo
 (lessp_TCC1 0
  (lessp_TCC1-1 nil 3704523468
   ("" (inst 1 "lambda (x, y: sequence[Time]): false")
    (("" (grind) nil nil)) nil)
   ((irreflexive? const-decl "bool" relations nil)
    (transitive? const-decl "bool" relations nil)
    (FALSE const-decl "bool" booleans nil)
    (strict_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (sequence type-eq-decl nil sequences nil)
    (Time type-eq-decl nil reo nil) (> const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   nil))
 (greaterp_TCC1 0
  (greaterp_TCC1-1 nil 3704523468
   ("" (expand "strict_order?")
    (("" (typepred "<")
      (("" (expand "strict_order?")
        (("" (flatten)
          (("" (split)
            (("1" (expand "irreflexive?") (("1" (propax) nil nil)) nil)
             ("2" (expand "transitive?")
              (("2" (skeep)
                (("2" (inst -4 "z" "y" "x") (("2" (assert) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((< const-decl "(strict_order?[sequence[Time]])" reo nil)
    (pred type-eq-decl nil defined_types nil)
    (sequence type-eq-decl nil sequences nil)
    (Time type-eq-decl nil reo nil) (> const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (transitive? const-decl "bool" relations nil)
    (irreflexive? const-decl "bool" relations nil)
    (strict_order? const-decl "bool" orders nil))
   nil))
 (Fifon_TCC1 0
  (Fifon_TCC1-1 nil 3717380668 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (Fifon_TCC2 0
  (Fifon_TCC2-1 nil 3717380668 ("" (termination-tcc) nil nil) nil nil))
 (trans_equal 0
  (no "no" 3702609618
   ("" (skosimp) (("" (expand "Teq") (("" (assert) nil nil)) nil)) nil)
   ((Teq const-decl "bool" reo nil)) shostak)
  (trans_equal-1 nil 3702609007
   ("" (skosimp) (("" (assert) (("" (grind) nil nil)) nil)) nil)
   ((Teq const-decl "bool" reo nil)) shostak))
 (trans_equal2 0
  (trans_equal2-1 nil 3702609484
   ("" (skosimp)
    (("" (expand "Teq")
      (("" (expand "next") (("" (propax) nil nil)) nil)) nil))
    nil)
   ((next const-decl "TD" reo nil) (Teq const-decl "bool" reo nil))
   shostak))
 (trans_equal3 0
  (trans_equal3-1 nil 3702609747
   ("" (skeep)
    (("" (expand "Tle")
      (("" (typepred "<")
        (("" (expand "strict_order?")
          (("" (flatten)
            (("" (expand "transitive?")
              (("" (inst -2 "T(s1)" "T(s2)" "T(s3)")
                (("" (assert) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((< const-decl "(strict_order?[sequence[Time]])" reo nil)
    (strict_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (sequence type-eq-decl nil sequences nil)
    (Time type-eq-decl nil reo nil) (> const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (TD type-eq-decl nil reo nil) (Data nonempty-type-decl nil reo nil)
    (transitive? const-decl "bool" relations nil)
    (Tle const-decl "bool" reo nil))
   shostak))
 (trans_equal5 0
  (trans_equal5-1 nil 3704464415
   ("" (skeep)
    (("" (expand "Tgt")
      (("" (typepred ">")
        (("" (expand "strict_order?")
          (("" (flatten)
            (("" (expand "transitive?")
              (("" (inst -2 "T(s1)" "T(s2)" "T(s3)")
                (("" (assert) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((> const-decl "(strict_order?[sequence[Time]])" reo nil)
    (strict_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (sequence type-eq-decl nil sequences nil)
    (Time type-eq-decl nil reo nil) (> const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (TD type-eq-decl nil reo nil) (Data nonempty-type-decl nil reo nil)
    (transitive? const-decl "bool" relations nil)
    (Tgt const-decl "bool" reo nil))
   shostak))
 (trans_equal6 0
  (trans_equal6-1 nil 3704464540
   ("" (skosimp) (("" (expand "Deq") (("" (assert) nil nil)) nil)) nil)
   ((Deq const-decl "bool" reo nil)) shostak))
 (T1 0
  (T1-1 nil 3702863204
   ("" (skosimp)
    (("" (expand "Sync")
      (("" (expand "Fifo1")
        (("" (expand "Teq")
          (("" (expand "Deq")
            (("" (expand "Tle")
              (("" (expand "next")
                (("" (flatten)
                  (("" (split)
                    (("1" (assert) nil nil) ("2" (propax) nil nil)
                     ("3" (assert) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((Fifo1 const-decl "bool" reo nil) (Deq const-decl "bool" reo nil)
    (next const-decl "TD" reo nil) (Tle const-decl "bool" reo nil)
    (Teq const-decl "bool" reo nil) (Sync const-decl "bool" reo nil))
   shostak))
 (fto 0
  (fto-1 nil 3717128651
   ("" (skosimp)
    (("" (expand "Sync")
      (("" (expand "Join")
        (("" (expand "Teq")
          (("" (expand "Deq")
            (("" (assert)
              (("" (flatten)
                (("" (split)
                  (("1" (assert) nil nil) ("2" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((Join const-decl "bool" reo nil) (Deq const-decl "bool" reo nil)
    (Teq const-decl "bool" reo nil) (Sync const-decl "bool" reo nil))
   shostak))
 (tcr 0
  (tcr-1 nil 3717478036
   ("" (skosimp)
    (("" (expand "Sync")
      (("" (expand "Join")
        (("" (expand "Teq")
          (("" (expand "Deq")
            (("" (assert)
              (("" (flatten)
                (("" (split)
                  (("1" (assert) nil nil) ("2" (assert) nil nil)
                   ("3" (assert) nil nil) ("4" (assert) nil nil)
                   ("5" (assert) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((Join const-decl "bool" reo nil) (Deq const-decl "bool" reo nil)
    (Teq const-decl "bool" reo nil) (Sync const-decl "bool" reo nil))
   shostak))
 (wcr 0
  (wcr-1 nil 3717478067
   ("" (skosimp)
    (("" (expand "Sync")
      (("" (expand "Join")
        (("" (expand "SyncD")
          (("" (expand "Teq")
            (("" (expand "Deq")
              (("" (assert)
                (("" (flatten)
                  (("" (split)
                    (("1" (assert) nil nil) ("2" (assert) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((Join const-decl "bool" reo nil) (Teq const-decl "bool" reo nil)
    (Deq const-decl "bool" reo nil) (SyncD const-decl "bool" reo nil)
    (Sync const-decl "bool" reo nil))
   shostak))
 (ex52 0
  (ex52-1 nil 3717130419
   ("" (induct "n")
    (("1" (skosimp)
      (("1" (assert)
        (("1" (expand "Lossysync")
          (("1" (expand "Sync")
            (("1" (expand "SyncD")
              (("1" (flatten)
                (("1" (assert)
                  (("1" (split)
                    (("1" (split)
                      (("1" (expand "next")
                        (("1" (expand "suffix")
                          (("1" (expand "nth")
                            (("1" (expand "Teq")
                              (("1"
                                (expand "Deq")
                                (("1" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (expand "Teq") (("2" (assert) nil nil))
                        nil))
                      nil)
                     ("2" (assert)
                      (("2" (expand "Teq") (("2" (assert) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (skosimp*)
      (("2" (expand "Teq")
        (("2" (inst?)
          (("2" (inst?)
            (("2" (inst?)
              (("2" (inst?)
                (("2" (assert)
                  (("2" (split)
                    (("1" (assert)
                      (("1" (expand "Lossysync")
                        (("1" (flatten)
                          (("1" (split)
                            (("1" (assert)
                              (("1"
                                (expand "next")
                                (("1"
                                  (expand "suffix")
                                  (("1" (grind) nil nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (grind) nil nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (grind) nil nil) ("3" (grind) nil nil)
                     ("4" (grind) nil nil) ("5" (grind) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (Data nonempty-type-decl nil reo nil)
    (sequence type-eq-decl nil sequences nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil) (Time type-eq-decl nil reo nil)
    (TD type-eq-decl nil reo nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (Sync const-decl "bool" reo nil)
    (Lossysync inductive-decl "bool" reo nil)
    (SyncD const-decl "bool" reo nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (Teq const-decl "bool" reo nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (next const-decl "TD" reo nil) (nth const-decl "TD" reo nil)
    (Deq const-decl "bool" reo nil)
    (suffix const-decl "sequence[Data]" reo nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (ex521 0
  (ex521-1 nil 3724710986
   ("" (induct "n")
    (("1" (skosimp)
      (("1" (expand "Lossysync")
        (("1" (expand "Sync")
          (("1" (expand "SyncD")
            (("1" (expand "Teq")
              (("1" (expand "Deq")
                (("1" (expand "nth")
                  (("1" (expand "next")
                    (("1" (expand "suffix")
                      (("1" (flatten) (("1" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (skosimp*)
      (("2" (inst -1 "A!1" "B!1" "C!1" "D!1" "E!1" "F!1" "G!1")
        (("2" (expand "Sync")
          (("2" (expand "Lossysync")
            (("2" (expand "SyncD")
              (("2" (expand "next")
                (("2" (expand "nth")
                  (("2" (expand "suffix")
                    (("2" (expand "Teq")
                      (("2" (expand "Deq")
                        (("2" (assert)
                          (("2" (flatten)
                            (("2" (split)
                              (("1" (propax) nil nil)
                               ("2" (propax) nil nil)
                               ("3" (assert) nil nil)
                               ("4" (assert) nil nil)
                               ("5" (propax) nil nil)
                               ("6" (propax) nil nil)
                               ("7" (propax) nil nil)
                               ("8" (propax) nil nil)
                               ("9" (propax) nil nil)
                               ("10" (propax) nil nil)
                               ("11" (propax) nil nil)
                               ("12" (propax) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nth const-decl "TD" reo nil)
    (suffix const-decl "sequence[Data]" reo nil)
    (next const-decl "TD" reo nil) (Deq const-decl "bool" reo nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (Teq const-decl "bool" reo nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (SyncD const-decl "bool" reo nil)
    (Lossysync inductive-decl "bool" reo nil)
    (Sync const-decl "bool" reo nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (TD type-eq-decl nil reo nil) (Time type-eq-decl nil reo nil)
    (> const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (sequence type-eq-decl nil sequences nil)
    (Data nonempty-type-decl nil reo nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (ex52new 0
  (ex52new-1 nil 3724489534
   ("" (induct "n")
    (("1" (skosimp)
      (("1" (expand "Sync")
        (("1" (expand "Lossysync")
          (("1" (expand "SyncD")
            (("1" (expand "next")
              (("1" (expand "suffix")
                (("1" (expand "Teq")
                  (("1" (expand "Deq")
                    (("1" (flatten)
                      (("1" (split)
                        (("1" (assert) nil nil) ("2" (assert) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (skosimp*)
      (("2" (inst -1 "A!1" "B!1" "C!1" "D!1" "E!1" "F!1" "G!1")
        (("2" (expand "Lossysync")
          (("2" (expand "Sync")
            (("2" (expand "SyncD")
              (("2" (expand "next")
                (("2" (expand "suffix")
                  (("2" (expand "nth")
                    (("2" (expand "Teq")
                      (("2" (expand "Deq")
                        (("2" (flatten) (("2" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nth const-decl "TD" reo nil) (next const-decl "TD" reo nil)
    (Deq const-decl "bool" reo nil)
    (suffix const-decl "sequence[Data]" reo nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (Teq const-decl "bool" reo nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (SyncD const-decl "bool" reo nil)
    (Lossysync inductive-decl "bool" reo nil)
    (Sync const-decl "bool" reo nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (TD type-eq-decl nil reo nil) (Time type-eq-decl nil reo nil)
    (> const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (sequence type-eq-decl nil sequences nil)
    (Data nonempty-type-decl nil reo nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (lemma7 0
  (lemma7-1 nil 3704464439
   ("" (skosimp)
    (("" (expand "Sync")
      (("" (expand "Teq")
        (("" (expand "Deq") (("" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((Teq const-decl "bool" reo nil) (Deq const-decl "bool" reo nil)
    (Sync const-decl "bool" reo nil))
   shostak))
 (T2LI 0
  (T2LI-1 nil 3717477561
   ("" (skosimp)
    (("" (expand "SyncD")
      (("" (expand "Teq")
        (("" (expand "Fifo1")
          (("" (expand "Tle")
            (("" (expand "next")
              (("" (expand "Deq")
                (("" (flatten)
                  (("" (assert)
                    (("" (split)
                      (("1" (assert)
                        (("1" (typepred "<")
                          (("1" (expand "strict_order?")
                            (("1" (expand "irreflexive?")
                              (("1"
                                (expand "transitive?")
                                (("1"
                                  (flatten)
                                  (("1"
                                    (inst?)
                                    (("1"
                                      (inst?)
                                      (("1"
                                        (inst?)
                                        (("1"
                                          (assert)
                                          (("1" (grind) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (grind) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((Teq const-decl "bool" reo nil) (Tle const-decl "bool" reo nil)
    (Deq const-decl "bool" reo nil)
    (transitive? const-decl "bool" relations nil)
    (TD type-eq-decl nil reo nil) (Data nonempty-type-decl nil reo nil)
    (Sync const-decl "bool" reo nil)
    (irreflexive? const-decl "bool" relations nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil) (Time type-eq-decl nil reo nil)
    (sequence type-eq-decl nil sequences nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_order? const-decl "bool" orders nil)
    (< const-decl "(strict_order?[sequence[Time]])" reo nil)
    (next const-decl "TD" reo nil) (Fifo1 const-decl "bool" reo nil)
    (SyncD const-decl "bool" reo nil))
   shostak))
 (R3LI 0
  (R3LI-1 nil 3717477578
   ("" (skosimp)
    (("" (skolem!)
      (("" (inst?)
        (("" (expand "Fifo1")
          (("" (expand "Sync")
            (("" (expand "Tle")
              (("" (expand "next")
                (("" (expand "Teq")
                  (("" (expand "Deq")
                    (("" (flatten) (("" (assert) nil nil)) nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((Data nonempty-type-decl nil reo nil)
    (sequence type-eq-decl nil sequences nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil) (Time type-eq-decl nil reo nil)
    (TD type-eq-decl nil reo nil) (Sync const-decl "bool" reo nil)
    (next const-decl "TD" reo nil) (Deq const-decl "bool" reo nil)
    (Teq const-decl "bool" reo nil) (Tle const-decl "bool" reo nil)
    (Fifo1 const-decl "bool" reo nil))
   shostak))
 (E4LI 0
  (E4LI-1 nil 3717477276
   ("" (skosimp)
    (("" (skolem!)
      (("" (inst?)
        (("" (expand "Sync")
          (("" (expand "Teq")
            (("" (expand "Deq")
              (("" (expand "Fifo1")
                (("" (expand "Tle")
                  (("" (expand "next")
                    (("" (expand "SyncD")
                      (("" (expand "Teq")
                        (("" (expand "Deq")
                          (("" (flatten) (("" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((Data nonempty-type-decl nil reo nil)
    (sequence type-eq-decl nil sequences nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil) (Time type-eq-decl nil reo nil)
    (TD type-eq-decl nil reo nil) (Teq const-decl "bool" reo nil)
    (Fifo1 const-decl "bool" reo nil) (next const-decl "TD" reo nil)
    (SyncD const-decl "bool" reo nil) (Tle const-decl "bool" reo nil)
    (Deq const-decl "bool" reo nil) (Sync const-decl "bool" reo nil))
   shostak))
 (ordering 0
           (ordering-1 nil 3717133242
            ("" (skosimp)
             (("" (assert)
               (("" (expand "Sync")
                 (("" (expand "SyncD")
                   (("" (expand "Fifo1")
                     (("" (expand "next")
                       (("" (expand "suffix")
                         (("" (expand "Teq")
                           (("" (expand "Deq")
                             (("" (expand "Tle")
                               ((""
                                 (assert)
                                 ((""
                                   (flatten)
                                   ((""
                                     (typepred "<")
                                     ((""
                                       (expand "strict_order?")
                                       ((""
                                         (expand "transitive?")
                                         ((""
                                           (expand "irreflexive?")
                                           (("" (assert) nil nil))
                                           nil))
                                         nil))
                                       nil))
                                     nil))
                                   nil))
                                 nil))
                               nil))
                             nil))
                           nil))
                         nil))
                       nil))
                     nil))
                   nil))
                 nil))
               nil))
             nil)
            ((SyncD const-decl "bool" reo nil)
             (next const-decl "TD" reo nil)
             (Teq const-decl "bool" reo nil)
             (Tle const-decl "bool" reo nil)
             (irreflexive? const-decl "bool" relations nil)
             (transitive? const-decl "bool" relations nil)
             (boolean nonempty-type-decl nil booleans nil)
             (bool nonempty-type-eq-decl nil booleans nil)
             (NOT const-decl "[bool -> bool]" booleans nil)
             (number nonempty-type-decl nil numbers nil)
             (number_field_pred const-decl "[number -> boolean]"
              number_fields nil)
             (number_field nonempty-type-from-decl nil number_fields
              nil)
             (real_pred const-decl "[number_field -> boolean]" reals
                        nil)
             (real nonempty-type-from-decl nil reals nil)
             (rational_pred const-decl "[real -> boolean]" rationals
                            nil)
             (rational nonempty-type-from-decl nil rationals nil)
             (integer_pred const-decl "[rational -> boolean]" integers
                           nil)
             (int nonempty-type-eq-decl nil integers nil)
             (>= const-decl "bool" reals nil)
             (nat nonempty-type-eq-decl nil naturalnumbers nil)
             (nonneg_real nonempty-type-eq-decl nil real_types nil)
             (> const-decl "bool" reals nil)
             (Time type-eq-decl nil reo nil)
             (sequence type-eq-decl nil sequences nil)
             (pred type-eq-decl nil defined_types nil)
             (strict_order? const-decl "bool" orders nil)
             (< const-decl "(strict_order?[sequence[Time]])" reo nil)
             (Deq const-decl "bool" reo nil)
             (suffix const-decl "sequence[Data]" reo nil)
             (Fifo1 const-decl "bool" reo nil)
             (Sync const-decl "bool" reo nil))
            shostak))
 (R4 0
  (R4-1 nil 3717479976
   ("" (skosimp)
    (("" (skolem!)
      (("" (inst?) (("" (flatten) (("" (postpone) nil nil)) nil)) nil))
      nil))
    nil)
   nil shostak))
 (gn 0
  (gn-1 nil 3717474408
   ("" (induct "n")
    (("1" (skosimp)
      (("1" (assert)
        (("1" (expand "Fifon")
          (("1" (expand "Fifo1")
            (("1" (flatten) (("1" (assert) nil nil)) nil)) nil))
          nil))
        nil))
      nil)
     ("2" (assert)
      (("2" (skosimp*)
        (("2" (expand Fifon -2)
          (("2" (skosimp)
            (("2" (inst - s1!1 s3!1)
              (("2" (assert)
                (("2" (expand "Fifo1")
                  (("2" (flatten)
                    (("2" (assert)
                      (("2" (expand "Deq")
                        (("2" (assert)
                          (("2" (hide-all-but (-1 -4 1))
                            (("2" (expand "Tle")
                              (("2"
                                (typepred "<")
                                (("2"
                                  (expand "strict_order?")
                                  (("2"
                                    (flatten)
                                    (("2"
                                      (expand "transitive?")
                                      (("2"
                                        (inst
                                         -
                                         "T(s1!1)"
                                         "T(s3!1)"
                                         "T(s2!1)")
                                        (("2" (assert) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (Data nonempty-type-decl nil reo nil)
    (sequence type-eq-decl nil sequences nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil) (Time type-eq-decl nil reo nil)
    (TD type-eq-decl nil reo nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (Fifon def-decl "bool" reo nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (Tle const-decl "bool" reo nil) (Deq const-decl "bool" reo nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (even_plus_odd_is_odd application-judgement "odd_int" integers nil)
    (Fifo1 const-decl "bool" reo nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (strict_order? const-decl "bool" orders nil)
    (< const-decl "(strict_order?[sequence[Time]])" reo nil)
    (transitive? const-decl "bool" relations nil))
   shostak))
 (g1 0
  (g1-1 nil 3717484638
   ("" (skosimp) (("" (expand "Fifon") (("" (propax) nil nil)) nil))
    nil)
   ((Fifon def-decl "bool" reo nil)) shostak))
 (seq 0
  (seq-1 nil 3717559635
   ("" (skosimp)
    (("" (expand "sequencer")
      (("" (expand "Tle")
        (("" (expand "Deq")
          (("" (expand "Fifo1e")
            (("" (expand "next")
              (("" (expand "Sync")
                (("" (expand "suffix")
                  (("" (assert)
                    (("" (typepred "<")
                      (("" (expand "strict_order?")
                        (("" (expand "irreflexive?")
                          (("" (expand "transitive?")
                            (("" (flatten)
                              ((""
                                (assert)
                                ((""
                                  (split)
                                  (("1"
                                    (assert)
                                    (("1" (grind) nil nil))
                                    nil)
                                   ("2" (grind) nil nil)
                                   ("3" (grind) nil nil)
                                   ("4" (grind) nil nil)
                                   ("5"
                                    (inst?)
                                    (("5" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((Tle const-decl "bool" reo nil) (Fifo1e const-decl "bool" reo nil)
    (Sync const-decl "bool" reo nil)
    (transitive? const-decl "bool" relations nil)
    (TD type-eq-decl nil reo nil) (Data nonempty-type-decl nil reo nil)
    (Fifo1 const-decl "bool" reo nil) (Teq const-decl "bool" reo nil)
    (e? const-decl "bool" reo nil) (nth const-decl "TD" reo nil)
    (Tgt const-decl "bool" reo nil)
    (> const-decl "(strict_order?[sequence[Time]])" reo nil)
    (irreflexive? const-decl "bool" relations nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil) (Time type-eq-decl nil reo nil)
    (sequence type-eq-decl nil sequences nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_order? const-decl "bool" orders nil)
    (< const-decl "(strict_order?[sequence[Time]])" reo nil)
    (suffix const-decl "sequence[Data]" reo nil)
    (next const-decl "TD" reo nil) (Deq const-decl "bool" reo nil)
    (sequencer const-decl "bool" reo nil))
   shostak))
 (seq1 0
  (seq1-1 nil 3724711552
   ("" (skosimp)
    (("" (expand "sequencer")
      (("" (expand "Fifo1e")
        (("" (expand "Fifo1")
          (("" (expand "Sync")
            (("" (expand "Tle")
              (("" (expand "Teq")
                (("" (expand "Deq")
                  (("" (expand "next")
                    (("" (assert)
                      (("" (typepred "<")
                        (("" (expand "strict_order?")
                          (("" (expand "irreflexive?")
                            (("" (expand "transitive?")
                              ((""
                                (flatten)
                                ((""
                                  (inst?)
                                  ((""
                                    (inst?)
                                    ((""
                                      (inst?)
                                      ((""
                                        (inst?)
                                        ((""
                                          (inst?)
                                          ((""
                                            (inst?)
                                            ((""
                                              (inst?)
                                              ((""
                                                (assert)
                                                ((""
                                                  (split)
                                                  (("1"
                                                    (propax)
                                                    nil
                                                    nil)
                                                   ("2"
                                                    (split)
                                                    (("1"
                                                      (assert)
                                                      (("1"
                                                        (grind)
                                                        (("1"
                                                          (grind)
                                                          (("1"
                                                            (postpone)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil)
                                                     ("2"
                                                      (postpone)
                                                      nil
                                                      nil)
                                                     ("3"
                                                      (postpone)
                                                      nil
                                                      nil)
                                                     ("4"
                                                      (postpone)
                                                      nil
                                                      nil)
                                                     ("5"
                                                      (postpone)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak)))


$$$ttreo.pvs
treo: THEORY 
BEGIN 

Importing reo

Input, T1, T2, TD1, Output: VAR TD;

seq: var sequence[Data];
i, n: var nat;

str_nth1(n,TD1): RECURSIVE TD = 
	        	IF n=0 THEN TD1 
	        	ELSE str_nth1(n-1, next(TD1))
	        	ENDIF 
		MEASURE n

str_nth(n, TD1): TD= nth(str_nth1(n,TD1), n)
Inc_T: AXIOM FORALL (T1, n): a?(str_nth(n,T1)) < a?(str_nth(n, next(T1)))

Teq(T1,T2): bool = FORALL (n:nat): a?(str_nth(n,T1)) = a?(str_nth(n,T2))
Tle(T1,T2): bool = FORALL (n:nat): a?(str_nth(n,T1)) < a?(str_nth(n,T2))
Tgt(T1,T2): bool = FORALL (n:nat): a?(str_nth(n,T1)) > a?(str_nth(n,T2))
Tneq(T1,T2): bool = FORALL (n:nat): a?(str_nth(n,T1)) /= a?(str_nth(n,T2))
Teqt(T1,T2)(t:Time): bool = FORALL (n:nat): a?(str_nth(n,T1)) + t = a?(str_nth(n,T2))
Tltt(T1,T2)(t:Time): bool = FORALL (n:nat): a?(str_nth(n,T1)) + t < a?(str_nth(n,T2))
Tgtt(T1,T2)(t:Time): bool = FORALL (n:nat): a?(str_nth(n,T1)) + t > a?(str_nth(n,T2))
Deq(T1, T2): bool= D(T1)= D(T2)

Teqtn(T1, T2)(t:Time)(n:posnat): Recursive bool= if n=1 THEN Teqt(T1,T2)(t) ELSE EXISTS(T3:TD): Teqtn(T1,T3)(t)(n-1) & Teqt(T3,T2)(t)
ENDif Measure n

Tlen(T1, T2)(n:posnat): Recursive bool= if n=1 THEN Teq(T1,T2) ELSE EXISTS(T3:TD): Tlen(T1,T3)(n-1) & Teq(T3,T2)
ENDif Measure n

Sync(Input, Output): bool = Teq(Input, Output) & Deq(Input, Output)

SyncD(Input, Output): bool = Teq(Input, Output)

Fifo1(Input, Output): bool = Tle(Input, Output) & 
	     	      	     Tle(Output, next(Input)) &
			     Deq(Input, Output)

Fifo1e(Input, Output)(e:Data)(n:nat): bool = Tgt(Input, Output) &  
Tle(Input,next(Output))   & e?(nth(Output,n))(e)
			     & Deq(Input, (next(Output)))

Fifon(s1, s2: TD)(n:posnat): Recursive bool = if n=1 Then Fifo1(s1, s2) ELSE
EXISTS(s3:TD): Fifon(s1,s3)(n-1) AND Fifo1(s3, s2) ENDIF MEasure n

ASD(Input, Output)(n:nat): INDUCTIVE bool=
	   	    	      (NOT a?(nth(Input,n))) =  a?(nth(Output, n))
			      & a?(nth(Input,n)) < a?(nth(Output, n))
			      & ASD((next(Input), Output))(n)
			      & a?(nth(Input,n))> a?(nth(Output, n))
			      & ASD(Input, next(Output))(n)

Lossysync(Input, Output)(n:nat): INDUCTIVE bool = 
		 		 Lossysync(next(Input), next(Output))(n) 
				& nth(Output,n)= nth(Input,n) 
				 OR Lossysync(next(Input), Output)(n)

s1,s2,s3: VAr TD

timeout, reset, expire, off:[Data->bool]

timert(Input, Output)(t:Time)(d:Data): bool = 
   (FORALL (n:nat): a?(str_nth(n,Input)) + t < a?(str_nth(n,(next(Input)))) 
      & Teqt(Input, Output)(t) & t?(str_nth(n, Output)) = timeout(d))

Ttimern(T1, T2)(t:Time)(d:Data)(n:posnat): Recursive bool= if n=1 then 
timert(T1,T2)(t)(d) ELSE Exists(T3:TD): Ttimern(T1,T3)(t)(d)(n-1) and timert(T2,T3)(t)(d)
ENDif measure n

offtimert(Input, Output)(t:Time)(d:Data): INDUCTIVE bool = 
      (FORALL (n:nat): t?(str_nth(n,Input)) = off(d) OR 
               a?(str_nth(n,Input))+t < a?(str_nth(n,next(Input)))
       & t?(nth(next(Input),n))= off(d) 
         IMPLIES (offtimert(next(next(Input)), Output)(t)(d))
       & (NOT t?(nth(next(Input),n)) = off(d) 
         IMPLIES  a?(nth(Input,n))= a?(nth(Input,n))+t
       &  t?(nth(Output, n)) =  off(d) 
       &  offtimert(next(Input), next(Output))(t)(d)))

rsttimert(Input, Output)(t:Time)(d:Data): Inductive bool =
      (FORALL (n:nat): t?(str_nth(n,Input)) = reset(d)  
       OR a?(str_nth(n,Input))+t < a?(str_nth(n,next(Input)))
       & t?(nth(next(Input),n))= reset(d) 
        IMPLIES (rsttimert(next(Input), Output)(t)(d))
       & (NOT t?(nth(next(Input),n)) = reset(d) 
        IMPLIES  a?(nth(Input,n))= a?(nth(Input,n))+t
       &  t?(nth(Output, n)) =  reset(d) 
       &  rsttimert(next(Input), next(Output))(t)(d)))

exptimert(Input, Output)(t:Time)(d:Data): Inductive bool =
      (FORALL (n:nat): t?(str_nth(n,Input)) = expire(d)  
       OR a?(str_nth(n,Input))+t < a?(str_nth(n,next(Input)))
       & t?(nth(next(Input),n))= expire(d) 
        IMPLIES a?(nth(Output,n)) = a?(nth(next(Input),n)) 
       & t?(nth(Output,n))= expire(d) 
       & (exptimert(next(Input), next(Output))(t)(d))
       & (NOT t?(nth(next(Input),n)) = expire(d) 
        IMPLIES  a?(nth(Input,n))= a?(nth(Input,n))+t
       & t?(nth(Output, n)) =  expire(d) 
       & exptimert(next(Input), next(Output))(t)(d)))

Merge(s1, s2,s3)(n:nat): INDUCTIVE  bool =
  (NOT (a?(nth(s1,n)))= (a?(nth(s2,n))))
  AND (
        ((a?(nth(s1,n)) < (a?(nth(s2,n)))) IMPLIES 
         nth(s3,n)= nth(s1,n))
  AND Merge(next(s1), s2, next(s3))(n))
  AND (
       ((a?(nth(s1,n)) > (a?(nth(s2,n)))) IMPLIES 
           nth(s3,n)= nth(s2,n))
  AND Merge(s1, next(s2), next(s3))(n))

eqtltt: LEMMA (FORALL (A,B:TD, t:Time,n:nat): Tltt(A,B)(t) 
               Implies a?(str_nth(n,A))+t < a?(str_nth(n,B)))

eqteqt: LEMMA (FORALL (A,B:TD, t:Time,n:nat): Teqt(A,B)(t) 
               Implies a?(str_nth(n,A))+t = a?(str_nth(n,B)))

teqttltt: LEMMA (FORALL (A,B,C:TD, t:Time): Teqt(A,B)(t) AND Tle(s2, s3) 
               Implies Tltt(A, C)(t))

tgt: LEMMA (FORALL(A,B: TD): Tgt(A, B) IMPLIES Tgt(next(s1), next(s2)))

tgttransfer: LEMMA (FORALL(A,B,C: TD): Tgt(next(B), A) AND Tgt(next(C), B)
              IMPLIES Tgt(next(next(s3)), A))

lt_transfer: LEMMA (FORALL(A,B,C:TD): Tle(A,B) and Tle(A,C) IMPLIES Tle(A,C))

eq_transfer: LEMMA (FORALL(A,B,C:TD, t:Time): Teq(A,B) and Teqt(B,C)(t) 
	     IMPLIES Teqt(A,C)(t))

merge_transfer: LEMMA (FORALL(A,B,C,D,E,F:TD, t:Time,n:nat): Merge(A,B,C)(n) and 
   Teqt(A, D)(t) and Teqt(B, E)(t) and Merge(D, E, F)(n) IMPLIES Teqt(C, F)(t))


LB_fifo1: THEOREM (FORALL (A,B,C,D,E:TD, t:Time,d:Data):
timert(A,C)(t)(d) AND Fifo1(A,D) AND SyncD(D,E) AND Fifo1(C,E)
  AND Sync(D,B) IMPLIES Deq(A,B) and Tltt(A,B)(t))

nt_connector: THEOREM (FORALL (A,B,C,D,E,F,G,I,C1,D1:TD, t:Time,d:Data,n:nat): 
   Sync(A,G) AND Lossysync(G,E)(n) AND Lossysync(G,F)(n) AND Sync(E,I) AND
   Sync(F,I) AND SyncD(G,I) AND Merge(E,F,I)(n) AND Sync(E,C) AND Sync(F,D) AND
   timert(C,C1)(t)(d) AND timert(D,D1)(t)(d) AND Merge(C1,D1,B)(n) IMPLIES Teqt(A,B)(t))

timed_fifo: THEOREM (FORALL (A,B,C,D,E:TD, t:Time,d:Data):
Fifo1(A,D) AND Fifo1(D,E) AND Sync(E,B) AND SyncD(C,E) AND 
Teqt(A,C)(t) IMPLIES Teqt(A,B)(t) and Tle(B,next(next(A))))

timed_fifon: THEOREM (FORALL (A,B,C,D,E:TD, t:Time,d:Data, n:nat):
Fifon(A,E)(n+1) AND Sync(E,B) AND SyncD(C,E) AND 
Ttimern(A,C)(t)(d)(n+1) IMPLIES Teqtn(A,B)(t)(n+1) AND Deq(A,B))

timed_fifon1: THEOREM (FORALL (A,B,C,D,E:TD, t:Time,d:Data, n:nat):
Fifon(A,E)(n+1) AND Sync(E,B) AND SyncD(C,E) AND 
Ttimern(A,C)(t)(d)(n+1) IMPLIES Teqtn(A,B)(t)(n+1) AND Deq(A,B)
 and Tlen(B,next(A))(n+1))

expire_fifo: THEOREM (FORALL (A,B,C,D,E,F,G,H:TD, t:Time,d:Data, n:nat):
Sync(A,C) AND Sync(C,F) AND Fifon(C,D)(n+1) AND timert(F,G)(t)(d) AND
Lossysync(G,H)(n) AND SyncD(D,H) AND Lossysync(D,E)(n) AND Sync(E,H) AND Sync(E,B)
IMPLIES Tltt(A,B)(t) & Deq(A,B))

expire_fifo1: THEOREM (FORALL (A,B,C,D,E,F,G,H:TD, t:Time,d:Data, n:nat):
Sync(A,C) AND Sync(C,F) AND Fifon(C,D)(n+1) AND timert(F,G)(t)(d) AND
Lossysync(G,H)(n) AND SyncD(D,H) AND Lossysync(D,E)(n) AND Sync(E,H) AND Sync(E,B)
IMPLIES Tltt(A,B)(t) & Deq(A,B))

End treo


$$$ttreo.prf
(treo
 (str_nth1_TCC1 0
  (str_nth1_TCC1-1 nil 3712123863 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil))
 (str_nth1_TCC2 0
  (str_nth1_TCC2-1 nil 3712123863 ("" (termination-tcc) nil nil) nil
   nil))
 (Teqtn_TCC1 0
  (Teqtn_TCC1-1 nil 3718532493 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (Teqtn_TCC2 0
  (Teqtn_TCC2-1 nil 3718532493 ("" (termination-tcc) nil nil) nil nil))
 (eqtltt 0
  (eqtltt-1 nil 3712123869
   ("" (skosimp)
    (("" (expand "Tltt")
      (("" (expand "b2n") (("" (inst?) nil nil)) nil)) nil))
    nil)
   ((b2n const-decl "nbit" bit nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Tltt const-decl "bool" treo nil))
   shostak))
 (eqteqt 0
  (eqteqt-1 nil 3712124119
   ("" (skosimp)
    (("" (expand "Teqt")
      (("" (expand "b2n") (("" (inst?) nil nil)) nil)) nil))
    nil)
   ((Teqt const-decl "bool" treo nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (b2n const-decl "nbit" bit nil))
   shostak))
 (teqttltt 0
  (teqttltt-1 nil 3712124314
   ("" (skosimp)
    (("" (expand "Teqt")
      (("" (expand "Tle")
        (("" (expand "Tltt")
          (("" (skosimp)
            (("" (expand "b2n")
              (("" (inst?)
                (("" (assert)
                  (("" (inst?)
                    (("" (typepred "<")
                      (("" (expand "strict_order?")
                        (("" (flatten)
                          (("" (expand "transitive?")
                            (("" (assert) (("" (grind) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((Tle const-decl "bool" treo nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (transitive? const-decl "bool" relations nil)
    (irreflexive? const-decl "bool" relations nil)
    (nth const-decl "TD" reo nil) (str_nth const-decl "TD" treo nil)
    (a? const-decl "bool" reo nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil) (Time type-eq-decl nil reo nil)
    (sequence type-eq-decl nil sequences nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_order? const-decl "bool" orders nil)
    (< const-decl "(strict_order?[sequence[Time]])" reo nil)
    (nnreal_plus_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (b2n const-decl "nbit" bit nil) (Tltt const-decl "bool" treo nil)
    (Teqt const-decl "bool" treo nil))
   shostak))
 (tgt 0
  (tgt-1 nil 3712124426
   ("" (skosimp)
    (("" (expand "Tgt")
      (("" (expand "next")
        (("" (expand "str_nth")
          (("" (expand "nth")
            (("" (expand "a?") (("" (propax) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((next const-decl "TD" reo nil) (nth const-decl "TD" reo nil)
    (a? const-decl "bool" reo nil) (str_nth const-decl "TD" treo nil)
    (Tgt const-decl "bool" treo nil))
   shostak))
 (tgttransfer 0
  (tgttransfer-1 nil 3712124607
   ("" (skosimp)
    (("" (expand "Tgt")
      (("" (expand "next")
        (("" (expand "str_nth")
          (("" (expand "nth")
            (("" (expand "b2n")
              (("" (expand "a?") (("" (propax) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((next const-decl "TD" reo nil) (nth const-decl "TD" reo nil)
    (a? const-decl "bool" reo nil) (b2n const-decl "nbit" bit nil)
    (str_nth const-decl "TD" treo nil)
    (Tgt const-decl "bool" treo nil))
   shostak))
 (lt_transfer 0
  (lt_transfer-1 nil 3712124714 ("" (skosimp) nil nil) nil shostak))
 (eq_transfer 0
  (eq_transfer-1 nil 3712124875
   ("" (skosimp)
    (("" (expand "Teq")
      (("" (expand "Teqt")
        (("" (expand "str_nth")
          (("" (expand "nth")
            (("" (expand "b2n")
              (("" (expand "a?") (("" (propax) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((Teq const-decl "bool" treo nil) (str_nth const-decl "TD" treo nil)
    (b2n const-decl "nbit" bit nil) (a? const-decl "bool" reo nil)
    (nth const-decl "TD" reo nil) (Teqt const-decl "bool" treo nil))
   shostak))
 (merge_transfer 0
  (merge_transfer-1 nil 3712125074
   ("" (skosimp)
    (("" (expand "Merge")
      (("" (expand "Teqt")
        (("" (expand "next")
          (("" (expand "b2n")
            (("" (inst?)
              (("" (skosimp)
                (("" (expand "a?") (("" (propax) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((Merge inductive-decl "bool" treo nil)
    (next const-decl "TD" reo nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (a? const-decl "bool" reo nil) (b2n const-decl "nbit" bit nil)
    (Teqt const-decl "bool" treo nil))
   shostak))
 (LB_fifo1 0
  (LB_fifo1-1 nil 3712371939
   ("" (skosimp)
    (("" (expand "timert")
      (("" (expand "Fifo1")
        (("" (expand "SyncD")
          (("" (expand "Sync")
            (("" (expand "Tltt")
              (("" (expand "Tle")
                (("" (expand "Deq")
                  (("" (expand "Teq")
                    (("" (split)
                      (("1" (expand "str_nth")
                        (("1" (expand "a?") (("1" (propax) nil nil))
                          nil))
                        nil)
                       ("2" (expand "str_nth")
                        (("2" (expand "a?") (("2" (propax) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((timert const-decl "bool" treo nil)
    (SyncD const-decl "bool" treo nil)
    (Tltt const-decl "bool" treo nil) (Deq const-decl "bool" treo nil)
    (a? const-decl "bool" reo nil) (str_nth const-decl "TD" treo nil)
    (Teq const-decl "bool" treo nil) (Tle const-decl "bool" treo nil)
    (Sync const-decl "bool" treo nil)
    (Fifo1 const-decl "bool" treo nil))
   shostak))
 (nt_connector 0
  (nt_connector-1 nil 3712372486
   ("" (induct "n")
    (("1" (skosimp)
      (("1" (expand "Lossysync")
        (("1" (expand "Merge")
          (("1" (expand "Sync")
            (("1" (expand "timert")
              (("1" (expand "SyncD")
                (("1" (flatten)
                  (("1" (assert)
                    (("1" (split)
                      (("1" (expand "next")
                        (("1" (expand "suffix")
                          (("1" (expand "nth")
                            (("1" (expand "Teqt")
                              (("1"
                                (assert)
                                (("1"
                                  (skosimp)
                                  (("1"
                                    (inst?)
                                    (("1"
                                      (assert)
                                      (("1"
                                        (expand "str_nth")
                                        (("1" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (expand "Teqt")
                        (("2" (skosimp)
                          (("2" (assert) (("2" (grind) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (skosimp*)
      (("2" (expand "Teqt")
        (("2" (inst?)
          (("2" (inst?)
            (("2" (inst?)
              (("2" (inst?)
                (("2" (inst?)
                  (("2" (skosimp)
                    (("2" (assert)
                      (("2" (split)
                        (("1" (inst?) nil nil)
                         ("2" (typepred "j!1")
                          (("2" (assert) (("2" (grind) nil nil)) nil))
                          nil)
                         ("3" (assert) (("3" (grind) nil nil)) nil)
                         ("4" (assert) (("4" (grind) nil nil)) nil)
                         ("5" (assert) (("5" (grind) nil nil)) nil)
                         ("6" (grind) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (sequence type-eq-decl nil sequences nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (Sync const-decl "bool" treo nil)
    (Lossysync inductive-decl "bool" treo nil)
    (SyncD const-decl "bool" treo nil)
    (Merge inductive-decl "bool" treo nil)
    (timert const-decl "bool" treo nil)
    (Teqt const-decl "bool" treo nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (str_nth const-decl "TD" treo nil) (Teq const-decl "bool" treo nil)
    (Deq const-decl "bool" treo nil)
    (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal"
     real_types nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (b2n const-decl "nbit" bit nil)
    (NOT const-decl "[bool -> bool]" booleans nil))
   shostak))
 (timed_fifo 0
  (timed_fifo-1 nil 3712372712
   ("" (skosimp) (("" (grind) nil nil)) nil)
   ((Teqt const-decl "bool" treo nil)
    (SyncD const-decl "bool" treo nil)
    (Sync const-decl "bool" treo nil) (Teq const-decl "bool" treo nil)
    (Fifo1 const-decl "bool" treo nil) (Deq const-decl "bool" treo nil)
    (next const-decl "TD" reo nil) (Tle const-decl "bool" treo nil)
    (b2n const-decl "nbit" bit nil) (a? const-decl "bool" reo nil)
    (str_nth const-decl "TD" treo nil) (nth const-decl "TD" reo nil))
   shostak))
 (timed_fifon 0
  (timed_fifon-1 nil 3717390941
   ("" (induct "n")
    (("1" (skosimp)
      (("1" (assert)
        (("1" (expand "Fifon")
          (("1" (expand "Ttimern")
            (("1" (expand "Sync")
              (("1" (expand "Teq")
                (("1" (expand "SyncD")
                  (("1" (expand "Fifo1")
                    (("1" (flatten)
                      (("1" (assert) (("1" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (assert)
      (("2" (skosimp*)
        (("2" (expand Fifon -2)
          (("2" (expand Ttimern -5)
            (("2" (skosimp)
              (("2" (inst?)
                (("2" (assert)
                  (("2" (hide -1)
                    (("2" (skosimp*)
                      (("2" (assert) (("2" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (Data nonempty-type-decl nil reo nil)
    (sequence type-eq-decl nil sequences nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil) (Time type-eq-decl nil reo nil)
    (TD type-eq-decl nil reo nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (Fifon def-decl "bool" treo nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Sync const-decl "bool" treo nil)
    (SyncD const-decl "bool" treo nil)
    (Ttimern def-decl "bool" treo nil) (Teqtn def-decl "bool" treo nil)
    (Deq const-decl "bool" treo nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (even_plus_odd_is_odd application-judgement "odd_int" integers nil)
    (Teq const-decl "bool" treo nil) (Fifo1 const-decl "bool" treo nil)
    (nth const-decl "TD" reo nil) (str_nth const-decl "TD" treo nil)
    (a? const-decl "bool" reo nil) (b2n const-decl "nbit" bit nil)
    (Tle const-decl "bool" treo nil) (next const-decl "TD" reo nil)
    (Teqt const-decl "bool" treo nil) (t? const-decl "bool" reo nil)
    (timert const-decl "bool" treo nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   shostak))
 (timed_fifon1 0
  (timed_fifon1-1 nil 3724557925
   ("" (induct "n")
    (("1" (skosimp)
      (("1" (expand "Fifon")
        (("1" (expand "Fifo1")
          (("1" (expand "Sync")
            (("1" (expand "SyncD")
              (("1" (expand "Ttimern")
                (("1" (expand "Teqtn")
                  (("1" (expand "Tlen")
                    (("1" (assert) (("1" (grind) nil nil)) nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (skosimp*)
      (("2" (expand Fifon -2)
        (("2" (expand Ttimern -5)
          (("2" (skosimp)
            (("2" (inst?)
              (("2" (assert)
                (("2" (skosimp*)
                  (("2" (assert) (("2" (grind) nil nil)) nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((odd_plus_odd_is_even application-judgement "even_int" integers
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (Fifo1 const-decl "bool" treo nil)
    (timert const-decl "bool" treo nil) (t? const-decl "bool" reo nil)
    (Teqt const-decl "bool" treo nil) (Teq const-decl "bool" treo nil)
    (Tle const-decl "bool" treo nil) (b2n const-decl "nbit" bit nil)
    (a? const-decl "bool" reo nil) (str_nth const-decl "TD" treo nil)
    (nth const-decl "TD" reo nil)
    (even_plus_odd_is_odd application-judgement "odd_int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (next const-decl "TD" reo nil) (Tlen def-decl "bool" treo nil)
    (Deq const-decl "bool" treo nil) (Teqtn def-decl "bool" treo nil)
    (Ttimern def-decl "bool" treo nil)
    (SyncD const-decl "bool" treo nil)
    (Sync const-decl "bool" treo nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (Fifon def-decl "bool" treo nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (TD type-eq-decl nil reo nil) (Time type-eq-decl nil reo nil)
    (> const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (sequence type-eq-decl nil sequences nil)
    (Data nonempty-type-decl nil reo nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (expire_fifo 0
  (expire_fifo-1 nil 3712373381
   ("" (induct "n")
    (("1" (assert)
      (("1" (skosimp)
        (("1" (expand "Fifon")
          (("1" (expand "Fifo1")
            (("1" (expand "Lossysync")
              (("1" (expand "Lossysync")
                (("1" (expand "Sync")
                  (("1" (expand "SyncD")
                    (("1" (expand "timert")
                      (("1" (expand "Teq")
                        (("1" (expand "Deq")
                          (("1" (expand "Tltt")
                            (("1" (flatten)
                              (("1"
                                (assert)
                                (("1"
                                  (hide -3 -9 -10 -11 -14)
                                  (("1"
                                    (prop)
                                    (("1"
                                      (skosimp)
                                      (("1"
                                        (inst?)
                                        (("1"
                                          (hide -7)
                                          (("1"
                                            (assert)
                                            (("1"
                                              (inst?)
                                              (("1"
                                                (typepred "n!1" "<")
                                                (("1"
                                                  (assert)
                                                  (("1"
                                                    (grind)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (inst?)
                                      (("1"
                                        (hide -7 -8)
                                        (("1"
                                          (assert)
                                          (("1" (grind) nil nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (assert)
                                        (("2" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (assert)
      (("2" (skosimp*)
        (("2" (expand Fifon -4)
          (("2" (inst?)
            (("2" (assert)
              (("2" (hide -1)
                (("2" (expand "Tltt")
                  (("2" (skosimp*)
                    (("2" (split)
                      (("1" (skosimp)
                        (("1" (typepred "<")
                          (("1" (expand "strict_order?")
                            (("1" (expand "irreflexive?")
                              (("1"
                                (expand "transitive?")
                                (("1"
                                  (assert)
                                  (("1" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (expand "Deq")
                        (("2" (assert) (("2" (grind) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (Data nonempty-type-decl nil reo nil)
    (sequence type-eq-decl nil sequences nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil) (Time type-eq-decl nil reo nil)
    (TD type-eq-decl nil reo nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (Sync const-decl "bool" treo nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (Fifon def-decl "bool" treo nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (timert const-decl "bool" treo nil)
    (Lossysync inductive-decl "bool" treo nil)
    (SyncD const-decl "bool" treo nil)
    (Tltt const-decl "bool" treo nil) (Deq const-decl "bool" treo nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (even_plus_odd_is_odd application-judgement "odd_int" integers nil)
    (Fifo1 const-decl "bool" treo nil) (Teq const-decl "bool" treo nil)
    (nnreal_plus_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (strict_order? const-decl "bool" orders nil)
    (< const-decl "(strict_order?[sequence[Time]])" reo nil)
    (posreal_plus_nnreal_is_posreal application-judgement "posreal"
     real_types nil)
    (next const-decl "TD" reo nil) (Tle const-decl "bool" treo nil)
    (b2n const-decl "nbit" bit nil) (a? const-decl "bool" reo nil)
    (str_nth const-decl "TD" treo nil) (nth const-decl "TD" reo nil)
    (transitive? const-decl "bool" relations nil)
    (irreflexive? const-decl "bool" relations nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (Teqt const-decl "bool" treo nil) (t? const-decl "bool" reo nil)
    (str_nth1 def-decl "TD" treo nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    nil)
   shostak))
 (expire_fifo1 0
  (expire_fifo1-1 nil 3724559479
   ("" (induct "n")
    (("1" (skosimp)
      (("1" (expand Fifon -3)
        (("1" (expand "Fifo1")
          (("1" (expand "Lossysync")
            (("1" (expand "Sync")
              (("1" (expand "SyncD")
                (("1" (expand "timert")
                  (("1" (expand "Teq")
                    (("1" (expand "Deq")
                      (("1" (expand "Tltt")
                        (("1" (flatten)
                          (("1" (assert)
                            (("1" (hide -3 -9 -10 -11 -14)
                              (("1"
                                (prop)
                                (("1"
                                  (skosimp)
                                  (("1"
                                    (inst -1 "n!1")
                                    (("1"
                                      (assert)
                                      (("1"
                                        (expand "str_nth")
                                        (("1"
                                          (expand "nth")
                                          (("1"
                                            (expand "a?")
                                            (("1" (propax) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (assert)
                                  (("2"
                                    (inst -1 "t!1")
                                    (("1"
                                      (expand "str_nth")
                                      (("1"
                                        (expand "nth")
                                        (("1"
                                          (expand "a?")
                                          (("1" (propax) nil nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (expand "str_nth")
                                      (("2"
                                        (expand "nth")
                                        (("2"
                                          (expand "a?")
                                          (("2" (propax) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (skosimp*)
      (("2" (expand "Fifon")
        (("2" (inst?)
          (("2" (hide -1)
            (("2" (expand "Tltt")
              (("2" (skosimp)
                (("2" (split)
                  (("1" (skosimp)
                    (("1" (typepred "<")
                      (("1" (expand "strict_order?")
                        (("1" (flatten)
                          (("1" (expand "irreflexive?")
                            (("1" (expand "transitive?")
                              (("1" (grind) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (expand "Deq")
                    (("2" (assert) (("2" (grind) nil nil)) nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (Data nonempty-type-decl nil reo nil)
    (sequence type-eq-decl nil sequences nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil) (Time type-eq-decl nil reo nil)
    (TD type-eq-decl nil reo nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (Sync const-decl "bool" treo nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (Fifon def-decl "bool" treo nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (timert const-decl "bool" treo nil)
    (Lossysync inductive-decl "bool" treo nil)
    (SyncD const-decl "bool" treo nil)
    (Tltt const-decl "bool" treo nil) (Deq const-decl "bool" treo nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (even_plus_odd_is_odd application-judgement "odd_int" integers nil)
    (Teq const-decl "bool" treo nil) (str_nth const-decl "TD" treo nil)
    (a? const-decl "bool" reo nil) (nth const-decl "TD" reo nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnreal_plus_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    nil (Fifo1 const-decl "bool" treo nil)
    (irreflexive? const-decl "bool" relations nil)
    (t? const-decl "bool" reo nil) (Teqt const-decl "bool" treo nil)
    (next const-decl "TD" reo nil) (Tle const-decl "bool" treo nil)
    (b2n const-decl "nbit" bit nil)
    (transitive? const-decl "bool" relations nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (strict_order? const-decl "bool" orders nil)
    (< const-decl "(strict_order?[sequence[Time]])" reo nil))
   shostak)))
